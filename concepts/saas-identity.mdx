---
title: 'SaaS Identity'
description: 'Understanding tenant isolation through JWT claims'
---

SaaS Identity is a core concept in Agentic Team OS that provides secure tenant isolation using JWT (JSON Web Token) claims. This pattern ensures that each request is properly authenticated and scoped to the correct tenant.

## Overview

The SaaS Identity pattern uses JWT tokens with custom claims to:
- Authenticate requests
- Identify tenants
- Scope access to resources
- Maintain security boundaries

<img src="/images/saas-identity.png" alt="SaaS Identity Sequence Diagram" />

The sequence diagram above illustrates the flow of a request through the SaaS Identity system:
1. The API receives and parses the incoming event
2. The token is validated with the SaaS Identity Provider(s)
3. The claims within the token are validated
4. Finally, the usecase is executed with the validated identity context

## JWT Claims Structure

```typescript
interface DecodedJwt {
  sub: string;          // Subject (User ID)
  metadata?: {
    keyId?: string;     // API Key ID
    // Additional metadata
  };
  // Standard JWT claims
  iss?: string;         // Issuer
  exp?: number;         // Expiration Time
  iat?: number;         // Issued At
}
```

## Implementation

The SaaS Identity pattern is implemented through a vending machine pattern:

```typescript
export interface ISaasIdentityVendingMachine {
    decodeJwt(token: string): Promise<JwtPayload>
    getValidUserFromAuthHeader(event: APIGatewayProxyEventV2): Promise<ValidUser | null>
    getValidUser(event: APIGatewayProxyEventV2): Promise<ValidUser>
}
```

### Validation Flow

1. **Token Extraction**
```typescript
// Extract JWT from Authorization header
const token = event.headers['authorization']?.split(' ')[1];
```

2. **Token Decoding**
```typescript
// Decode and verify JWT
const decodedJwt = await this.decodeJwt(token);
const parsedJwt = DecodedJwtSchema.parse(decodedJwt);
```

3. **User Validation**
```typescript
// Extract user details from JWT claims
const userDetails: ValidUser = {
    userId: parsedJwt.sub,
    keyId: parsedJwt.metadata?.keyId,
};

// Validate user details
const isValidUser = ValidUserSchema.safeParse(userDetails);
```

## Security Considerations

1. **Token Validation**
   - Verify token signature
   - Check expiration time
   - Validate required claims
   - Enforce schema validation

2. **Tenant Isolation**
   - Each request is scoped to a tenant
   - Resources are partitioned by tenant
   - Cross-tenant access is prevented
   - Metadata claims enforce boundaries

3. **Error Handling**
   - Invalid tokens return 401 Unauthorized
   - Missing claims return 403 Forbidden
   - Validation errors are logged
   - Security events are audited

## Usage Example

Here's how to use the SaaS Identity pattern in your API endpoints:

```typescript
export class SecureEndpoint {
  constructor(
    private readonly identityVendingMachine: ISaasIdentityVendingMachine
  ) {}

  async handleRequest(event: APIGatewayProxyEventV2) {
    try {
      // Validate user and get identity
      const user = await this.identityVendingMachine.getValidUser(event);

      // Use user details for tenant isolation
      const resources = await this.getResourcesForUser(user.userId);

      return {
        statusCode: 200,
        body: JSON.stringify(resources)
      };
    } catch (error) {
      return this.handleAuthError(error);
    }
  }
}
```

## Integration with Clerk

Agentic Team OS uses Clerk for authentication, which provides:
- JWT token issuance
- Custom claim management
- Token verification
- User management

```typescript
export class ClerkService implements IJwtService {
  async decodeToken(token: string): Promise<JwtPayload> {
    // Verify and decode token using Clerk
    const decodedToken = await clerk.verifyToken(token);
    return decodedToken;
  }
}
```

## Best Practices

1. **Token Management**
   - Use short-lived tokens
   - Implement token refresh
   - Rotate keys regularly
   - Monitor token usage

2. **Claim Design**
   - Keep claims minimal
   - Use standard claims when possible
   - Document custom claims
   - Version claim schemas

3. **Security Headers**
   - Use Bearer authentication
   - Set secure cookie flags
   - Implement CORS properly
   - Add security headers

4. **Error Handling**
   - Return appropriate status codes
   - Don't leak sensitive info
   - Log security events
   - Monitor failed attempts

## Common Use Cases

1. **API Authentication**
```typescript
// Protect API endpoints
app.use(async (req, res, next) => {
  const user = await identityVendingMachine.getValidUser(req);
  req.user = user;
  next();
});
```

2. **Resource Access**
```typescript
// Scope database queries
const getUserData = async (userId: string) => {
  return db.query({
    TableName: 'UserData',
    KeyConditionExpression: 'userId = :userId',
    ExpressionAttributeValues: {
      ':userId': userId
    }
  });
};
```

3. **Service-to-Service**
```typescript
// Pass identity context between services
const callService = async (user: ValidUser) => {
  return axios.post('/api/service', data, {
    headers: {
      'X-User-ID': user.userId,
      'X-Key-ID': user.keyId
    }
  });
};
```

## Next Steps

- [Security Overview](/security/overview)
- [Clerk Integration](/essentials/configuration/clerk)
- [API Template](/templates/api-template) 