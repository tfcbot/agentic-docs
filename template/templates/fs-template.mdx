---
title: 'Full-Stack Template'
description: 'Unified template for building a complete AI agent platform'
---

The Full-Stack (FS) Template is a unified, comprehensive solution for building AI agent applications. It combines the frontend, backend, and infrastructure into a single, cohesive codebase, making it easier to develop, deploy, and maintain your AI agent platform.

This template follows a hexagonal architecture pattern that separates business logic from external concerns, making your codebase more maintainable and testable.

## Key Features

- **Unified Codebase**: Single repository for frontend, backend, and infrastructure
- **Hexagonal Architecture**: Clean separation of concerns for better maintainability
- **SST Infrastructure**: Infrastructure as code with AWS CDK and SST
- **React Frontend**: Modern React frontend with authentication and agent UI
- **Serverless Backend**: Scalable serverless backend with AWS Lambda and DynamoDB
- **Agent Framework**: Structured approach to building and deploying AI agents

You can find the full source code for the FS template [here](https://github.com/tfcbot/fs-template).

## Project Structure

The FS template follows a monorepo structure with packages for core, functions, frontend, metadata, and utils:

```bash
fs-template/
├── docs/                           # Documentation
├── infra/                          # Infrastructure definitions
│   ├── api.ts                      # API Gateway configuration
│   ├── auth.ts                     # Authentication resources
│   ├── database.ts                 # DynamoDB tables
│   ├── frontend.ts                 # Frontend configuration
│   ├── web.ts                      # Frontend and API configurations
│   ├── orchestrator.ts             # Event processing and queues
│   └── secrets.ts                  # Secret management
├── lib/                            # AWS service wrappers
│   ├── dynamodb.ts                 # DynamoDB client wrapper
│   ├── s3.ts                       # S3 client wrapper
│   ├── sqs.ts                      # SQS client wrapper
│   └── ...                         # Other AWS service wrappers
├── packages/                       # Core packages directory
│   ├── core/                       # Core business logic
│   │   └── src/
│   │       ├── research-agent/     # Example agent module (hexagonal architecture)
│   │       │   ├── adapters/       # Input/output adapters
│   │       │   │   ├── primary/    # Input adapters
│   │       │   │   └── secondary/  # Output adapters
│   │       │   └── usecase/        # Business logic
│   │       └── lib/                # Shared libraries
│   ├── functions/                  # Lambda function handlers
│   │   └── src/
│   │       └── agent-runtime.api.ts # API handlers
│   ├── frontend/                   # React frontend application
│   │   └── src/
│   │       ├── app/                # Next.js app router
│   │       └── components/         # React components
│   ├── metadata/                   # Shared type definitions
│   │   └── src/
│   │       └── agents/             # Agent schemas
│   └── utils/                      # Shared utilities
│       └── src/
│           └── tools/              # Utility functions
└── sst.config.ts                   # SST configuration
```

## The lib/ Directory

The `lib/` directory contains wrappers around AWS services that provide consistent patterns and reduce boilerplate code. These wrappers offer:

1. **Simplified Interfaces**: Clean, typed interfaces for interacting with AWS services
2. **Error Handling**: Consistent error handling patterns across all AWS interactions
3. **Retry Logic**: Built-in retry mechanisms for transient failures
4. **Logging**: Standardized logging for all AWS operations
5. **Testing**: Easier mocking for unit and integration tests

Example of the DynamoDB wrapper:

```typescript
// lib/dynamodb.ts
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, GetCommand, PutCommand, QueryCommand } from '@aws-sdk/lib-dynamodb';

export class DynamoDBService {
  private client: DynamoDBDocumentClient;

  constructor() {
    const dynamoClient = new DynamoDBClient({});
    this.client = DynamoDBDocumentClient.from(dynamoClient);
  }

  async getItem<T>(tableName: string, key: Record<string, any>): Promise<T | null> {
    try {
      const command = new GetCommand({
        TableName: tableName,
        Key: key,
      });
      
      const response = await this.client.send(command);
      return (response.Item as T) || null;
    } catch (error) {
      console.error('Error getting item from DynamoDB:', error);
      throw error;
    }
  }

  async putItem(tableName: string, item: Record<string, any>): Promise<void> {
    try {
      const command = new PutCommand({
        TableName: tableName,
        Item: item,
      });
      
      await this.client.send(command);
    } catch (error) {
      console.error('Error putting item to DynamoDB:', error);
      throw error;
    }
  }

  // Additional methods for query, scan, update, delete, etc.
}

// Export a singleton instance
export const dynamoDBService = new DynamoDBService();
```

## Hexagonal Architecture

The FS template implements a hexagonal architecture (also known as ports and adapters) for agent modules. This architecture separates the core business logic from external concerns, making the system more maintainable, testable, and adaptable to change.

<img src="/images/hexagonal-architecture.png" alt="Hexagonal Architecture Diagram" className="w-full rounded-lg" />

The key components of this architecture are:

1. **Primary Adapters (Input)**: Handle incoming requests and transform them into a format the use cases can process
2. **Use Cases (Business Logic)**: Contain the core business logic independent of external systems
3. **Secondary Adapters (Output)**: Handle communication with external systems like AI providers and databases

## Infrastructure as Code

The FS template uses SST (Serverless Stack) for infrastructure as code. This allows you to define your AWS resources in TypeScript and deploy them with a single command.

Example API route configuration:

```typescript
// infra/api.ts
import { Api } from "sst/constructs";

export const api = new Api(stack, "Api", {
  routes: {
    "POST /research": {
      function: {
        handler: "packages/functions/src/agent-runtime.api.requestResearchHandler",
        bind: [researchTable, openaiApiKey],
      },
    },
    "GET /research/{id}": {
      function: {
        handler: "packages/functions/src/agent-runtime.api.getResearchHandler",
        bind: [researchTable],
      },
    },
  },
});
```

Example database configuration:

```typescript
// infra/database.ts
import { Table } from "sst/constructs";

export const researchTable = new Table(stack, "Research", {
  fields: {
    userId: "string",
    id: "string",
    title: "string",
    content: "string",
    status: "string",
  },
  primaryIndex: { partitionKey: "userId", sortKey: "id" },
});
```

Example API route definition:

```typescript
// infra/web.ts
api.route("POST /personas", {
  link: [personasTable, openaiApiKey],
  handler: "./packages/functions/src/agent-runtime.api.requestPersonaHandler",
})
```

## Environment Configuration

Create a `.env.local` file in the project root:

```bash
# AWS/SST Configuration
awsProfile=my-profile

# Authentication
clerkSecretKey=<clerk_secret_key>
clerkPublishableKey=<clerk_publishable_key>

# AI Services
openaiApiKey=<openai_api_key>

# Payments
stripeSecretKey=<stripe_secret_key>
stripePublishableKey=<stripe_publishable_key>
stripeWebhookSecret=<stripe_webhook_secret>

# Domain Configuration
baseDomain=<your-domain.com>
CLOUDFLARE_API_TOKEN=<cloudflare_token>
```

## Development Workflow

1. **Install dependencies**:
   ```bash
   bun install
   ```

2. **Start the development server**:
   ```bash
   bun sst dev
   ```

3. **Run the frontend**:
   ```bash
   cd packages/frontend
   bun dev
   ```

## Deployment

The FS template supports multiple deployment options:

1. **Development deployment**:
   ```bash
   bun sst deploy --stage dev
   ```

2. **Production deployment**:
   ```bash
   bun sst deploy --stage prod
   ```

## Next Steps

- [Adding New Agents](/template/guides/adding-agents)

