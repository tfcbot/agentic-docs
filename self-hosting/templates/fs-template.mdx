---
title: 'Full-Stack Template'
description: 'Unified template for building agentic applications with a hexagonal architecture'
---

The Full-Stack (FS) Template provides a unified approach to building agentic applications with a clean, hexagonal architecture. This template consolidates the previously separate API, Dashboard, and Landing templates into a single, cohesive project structure.

You can find the full source code for the FS template [here](https://github.com/tfcbot/fs-template).

## Key Benefits

- **Unified Architecture**: Single repository for frontend, backend, and infrastructure
- **Hexagonal Design**: Clear separation of concerns with ports and adapters pattern
- **Simplified Agent Creation**: Standardized approach to adding new agents
- **Consistent Development Experience**: Unified tooling and development workflow
- **Streamlined Deployment**: Single deployment process for all components

## Project Structure

```bash
fs-template/
├── docs/                           # Documentation
│   ├── add_new_agents.md           # Guide for adding new agents
│   ├── auth.md                     # Authentication documentation
│   └── ...                         # Other documentation
├── infra/                          # Infrastructure definitions
│   ├── database.ts                 # DynamoDB tables
│   ├── web.ts                      # Frontend and API configurations
│   ├── orchestrator.ts             # Event processing and queues
│   └── secrets.ts                  # Secret management
├── packages/                       # Core packages directory
│   ├── core/                       # Core business logic
│   │   └── src/
│   │       ├── agent-name/         # Agent modules (hexagonal architecture)
│   │       │   ├── adapters/       # Input/output adapters
│   │       │   │   ├── primary/    # Input adapters
│   │       │   │   └── secondary/  # Output adapters
│   │       │   └── usecase/        # Business logic
│   │       └── ...
│   ├── frontend/                   # React frontend application
│   │   ├── public/                 # Static assets
│   │   └── src/                    # Frontend source code
│   ├── functions/                  # Lambda function handlers
│   │   └── src/                    # Function source code
│   ├── metadata/                   # Shared schemas and types
│   │   └── agents/                 # Agent-specific schemas
│   └── utils/                      # Shared utilities
│       └── src/                    # Utility source code
└── sst.config.ts                   # SST configuration
```

## Hexagonal Architecture

The FS template implements a hexagonal architecture (also known as ports and adapters) for agent modules. This architecture separates the core business logic from external concerns, making the system more maintainable, testable, and adaptable to change.

<img src="/images/hexagonal-architecture.png" alt="Hexagonal Architecture Diagram" className="w-full rounded-lg" />

### Key Components

1. **Primary Adapters (Input)**: Handle incoming requests and transform them into a format the use cases can process
   - HTTP Request Adapters
   - Event Handlers

2. **Use Cases (Business Logic)**: Contain the core business logic independent of external systems
   - Implement domain-specific rules
   - Orchestrate the flow of data

3. **Secondary Adapters (Output)**: Handle communication with external systems
   - AI Provider Adapters (OpenAI, etc.)
   - Database Adapters
   - Third-party Service Adapters

## Agent Implementation Pattern

When implementing a new agent, you'll follow this standardized directory structure:

```
<YOUR-AGENT-NAME>/
├── adapters/
│   ├── primary/    (input adapters - handle incoming requests)
│   │   ├── request-<YOUR-AGENT-NAME>.adapter.ts
│   │   └── get-<YOUR-AGENT-NAME>.adapter.ts
│   └── secondary/  (output adapters - handle outgoing operations)
│       ├── openai.adapter.ts
│       └── datastore.adapter.ts
└── usecase/      (core business logic)
    └── <YOUR-AGENT-NAME>.usecase.ts
```

## Schema-Driven Development

The FS template uses Zod for schema validation throughout the application:

```typescript
// In metadata/agents/<YOUR-AGENT-NAME>.schema.ts
import { z } from 'zod';

export const Request<YOUR-AGENT-NAME>InputSchema = z.object({
  prompt: z.string(),
  id: z.string().optional().default(uuidv4()),
  userId: z.string(),
  keyId: z.string(),
});

export const <YOUR-AGENT-NAME>OutputSchema = z.object({
  id: z.string(),
  userId: z.string(),
  title: z.string(),
  content: z.string(),
  status: z.nativeEnum(<YOUR-AGENT-NAME>Status).default(<YOUR-AGENT-NAME>Status.PENDING),
});

export type Request<YOUR-AGENT-NAME>Input = z.infer<typeof Request<YOUR-AGENT-NAME>InputSchema>;
export type <YOUR-AGENT-NAME>Output = z.infer<typeof <YOUR-AGENT-NAME>OutputSchema>;
```

## Infrastructure with SST

The FS template uses SST (Serverless Stack) v3 for infrastructure as code:

```typescript
// infra/database.ts
export const personaTable = new sst.aws.Dynamo("Persona", {
    fields: {
        userId: "string",
        personaId: "string",
        personaStatus: "string",
    },
    primaryIndex: {hashKey: "personaId"},
    globalIndexes: {
        UserIdIndex: { hashKey: "userId" },
        StatusIndex: { hashKey: "personaStatus" }
    }
})

// infra/web.ts
export const api = new sst.aws.ApiGatewayV2('BackendApi')

api.route("GET /personas", {
  link: [...apiResources],
  handler: "./packages/functions/src/agent-runtime.api.getAllUserPersonasHandler",
})
```

## Frontend Integration

The frontend package is a React application that communicates with the backend API:

```typescript
// packages/frontend/src/api/agents.ts
import { AgentResponse } from '@/types';

export const requestAgent = async (
  agentId: string, 
  input: Record<string, any>
): Promise<AgentResponse> => {
  const response = await fetch(`/api/agents/${agentId}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(input),
  });
  
  if (!response.ok) {
    throw new Error('Failed to request agent');
  }
  
  return response.json();
};
```

## Environment Configuration

Create a `.env.local` file in the project root:

```bash
# AWS/SST Configuration
AWS_PROFILE=my-profile

# Authentication
clerkSecretKey=<clerk_secret_key>
clerkPublishableKey=<clerk_publishable_key>

# AI Services
openaiApiKey=<openai_api_key>

# Payments
stripeSecretKey=<stripe_secret_key>
stripePublishableKey=<stripe_publishable_key>
stripeWebhookSecret=<stripe_webhook_secret>

# Domain Configuration
baseDomain=<your-domain.com>
CLOUDFLARE_API_TOKEN=<cloudflare_token>
```

## Development Workflow

1. **Install Dependencies**:
   ```bash
   bun install
   ```

2. **Start Development Environment**:
   ```bash
   bun run dev
   ```

3. **Deploy to Staging**:
   ```bash
   bun sst deploy --stage staging
   ```

4. **Deploy to Production**:
   ```bash
   bun sst deploy --stage prod
   ```

## Migrating from Legacy Templates

If you're currently using the separate API, Dashboard, or Landing templates, consider migrating to the unified FS template for a more streamlined development experience. The migration process involves:

1. Setting up the FS template repository
2. Transferring your custom agents to the new hexagonal architecture
3. Migrating your frontend customizations
4. Updating your infrastructure configuration

For detailed migration steps, refer to the [Migration Guide](/self-hosting/guides/migration-guide).

## Next Steps

- [Adding New Agents](/self-hosting/guides/adding-agents)
- [Understanding the Hexagonal Architecture](/self-hosting/concepts/architecture)
- [Deployment and Infrastructure](/self-hosting/guides/automate-deployments)

